在这段代码里，你会遇到类似这样的编译错误：

```
no match for ‘operator=’ (operand types are ‘Point’ and ‘Point’)
```

这是因为你把赋值运算符定义成了：

```cpp
Point& operator=(Point& p);
```

它只能接受一个 **非常量的左值引用** (`Point&`) 作为参数。但表达式 `p1 + p2` 的结果是一个 **临时对象**（右值），C++ 不允许将临时对象绑定到非常量的左值引用上，因此找不到合适的 `operator=`。

------

## 解决办法

1. **用 `const Point&` 接收参数**
    把赋值运算符改成接受常量引用，这样既能绑定左值，也能绑定右值局部临时对象。
2. **把 `operator+`、`operator-` 等标记为 `const`**
    明确告诉编译器，这些操作不会修改当前对象。

下面是一份修改后的最小示例：

```cpp

    Point& operator=(const Point& p) {
        if (this != &p) {
            x = p.x;
            y = p.y;
            z = p.z;
        }
        return *this;
    }
int main() {
    Point p1(1, 2, 3), p2(3, 4, 5), p4;
    Point p3 = p1 + p2;   // 调用拷贝构造
    p4 = p1 + p2;         // 现在能调用 operator=(const Point&)
    cout << "p3: "; p3.showpoint();
    cout << "p4: "; p4.showpoint();
    return 0;
}
```

这样一来：

- `p1 + p2` 返回的临时对象可以绑定到 `operator=(const Point&)` 上，赋值就可以正常编译。



下面我从几个关键知识点来详细讲解，为你理清 C++ 中与本例相关的语法和“常见坑”。

------

## 1. 左值（lvalue）与右值（rvalue）

- **左值（lvalue）**
   表示“有名字”的对象，你可以对它取地址，也可以修改它。例如：

  ```cpp
  Point p;     // p 是左值
  int x = 3;   // x 是左值
  ```

- **右值（rvalue）**
   临时产生、没有名字、生命周期极短的值，不能取地址，也不能绑定到非常量左值引用。例如：

  ```cpp
  p1 + p2      // 表达式结果是一个临时 Point（右值）
  3 + 4        // 整型临时值（右值）
  ```

### 为什么 `Point& operator=(Point& p)` 绑不到右值？

C++ 规定：**非常量左值引用（`T&`）不能绑定到右值**。而你的赋值操作写成了：

```cpp
Point& operator=(Point& p);
```

它只能接受“有名字”的 `Point` 对象。却不能接受 `p1 + p2` 产生的那个临时对象（右值），因此报“找不到匹配的 `operator=`”错误。

------

## 2. 常量引用（`const T&`）与引用绑定规则

- **`const T&`** 可以绑定到左值，也可以绑定到右值。
- **`T&`** 只能绑定到左值。
- **`T&&`**（右值引用）只能绑定到右值（C++11 及以后）。

**解决方案**：把赋值运算符的参数改成 `const Point& p`，这样既能接受 `p2` 这样的左值，也能接受 `p1 + p2` 产生的临时右值：

```cpp
Point& operator=(const Point& p);
```

------

## 3. 成员函数的 `const` 限定

当一个成员函数不修改对象的任何数据成员时，应当在函数后面加上 `const`，告诉编译器它是只读操作：

```cpp
Point operator+(const Point& p) const { … }      // 不修改 *this
void showpoint() const { … }                     // 也不修改 *this
int operator[](int i) const { … }                // 读取而已
```

这样做好处有：

1. 更严谨：保证你不会在无意中修改成员变量。
2. 可以对 `const Point` 对象调用这些函数。

------

## 4. 运算符重载的习惯写法

- **二元算术运算符**
   通常写成接收 `const T&`、并在方法后加 `const`：

  ```cpp
  Point operator+(const Point& other) const;
  Point operator-(const Point& other) const;
  ```

- **赋值运算符**

  - 接收 `const T&`
  - 返回 `T&`（便于链式赋值 `a = b = c;`）
  - 做自我赋值检查 `if (this != &other)`

  ```cpp
  Point& operator=(const Point& other) {
      if (this != &other) {
          x = other.x;
          y = other.y;
          z = other.z;
      }
      return *this;
  }
  ```

- **递增/递减运算符**

  - 前置：`Point& operator++();`
  - 后置：`Point operator++(int);`
     后置版本的 `int` 参数只是一个“占位”，用来区分前置和后置，通常返回修改前的副本。

------

## 5. 三法则 & 五法则（Rule of Three / Five）

当你的类管理“资源”（如动态内存、文件句柄）时，需要显式定义：

1. **析构函数**
2. **拷贝构造函数**
3. **拷贝赋值运算符**

—— 这是“三法则”。如果用到 C++11 特性，还需加：
 \4. **移动构造函数**
 \5. **移动赋值运算符**

本例中 `Point` 不管理外部资源，所以编译器生成的拷贝构造函数就够用了。但你既然手写了赋值运算符，就请注意三法则：通常要同时提供拷贝构造函数和赋值运算符。

------

## 6. 下标运算符重载（`operator[]`）

- 返回类型带 `&`，才能做写操作：

  ```cpp
  int& operator[](int i);
  ```

- 也建议提供 `const` 版本，以便读取 `const` 对象：

  ```cpp
  int operator[](int i) const;
  ```

- 加入越界检查，提升安全性：

  ```cpp
  switch(i) {
    case 0: return x;
    case 1: return y;
    case 2: return z;
    default: throw out_of_range("Index must be 0,1,2");
  }
  ```

------

## 7. 小结

1. **非常量左值引用（`T&`）不能绑定右值** → 导致 `p4 = p1 + p2;` 无法找到 `operator=`。
2. **用 `const T&` 接收参数** 能同时接受左值和右值。
3. **成员函数加 `const` 限定** 保证接口的清晰与安全。
4. **遵循三/五法则**，若手写赋值运算符，通常也要显式写拷贝构造函数。
5. **下标运算符** 应同时提供读写和只读两个版本，并做越界检查。

掌握这些语法要点，就能更加游刃有余地进行 C++ 类设计和运算符重载了！如果还有更深入的问题，欢迎继续交流 :)